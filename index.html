<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 水流模擬器</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #f0f0f0; }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 300px;
            z-index: 100;
        }
        #info-panel label { display: block; margin-bottom: 5px; font-weight: bold; }
        #info-panel input[type="file"],
        #info-panel input[type="number"],
        #info-panel select { /* 新增 select 的樣式 */
            width: calc(100% - 12px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #info-panel button {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 5px; /* 增加按鈕間距 */
        }
        #info-panel button:hover { background-color: #0056b3; }
        #simulation-status {
            margin-top: 15px;
            font-size: 14px;
            color: #333;
        }
        #simulation-status span { font-weight: bold; }
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 200;
            display: none; /* 預設隱藏 */
        }
        .hint-text { /* 提示框樣式 */
            font-size: 10px;
            color: gray;
            margin-top: -5px;
            margin-bottom: 10px;
            text-align: left;
            word-wrap: break-word;
            white-space: normal;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h2>水流模擬設定</h2>
        <label for="terrainFile">上傳地形 Excel (.xlsx/.xls):</label>
        <input type="file" id="terrainFile" accept=".xlsx,.xls">
        <div class="hint-text" id="file-path-display">尚未選擇檔案</div>

        <label for="dx">X 方向間距 (m):</label>
        <input type="number" id="dx" value="10" step="1" min="1">

        <label for="dy">Y 方向間距 (m):</label>
        <input type="number" id="dy" value="10" step="1" min="1">

        <label for="rainfallType">降雨類型:</label>
        <select id="rainfallType">
            <option value="A">A: 大雨 (80mm/24hr)</option>
            <option value="B">B: 豪雨 (200mm/24hr)</option>
            <option value="C">C: 豪大雨 (350mm/24hr)</option>
            <option value="D">D: 超大豪雨 (500mm/24hr)</option>
        </select>
        <div class="hint-text">
            A: 80mm/24hr, B: 200mm/24hr,<br>
            C: 350mm/24hr, D: 500mm/24hr
        </div>


        <label for="simTime">模擬時間 (分鐘):</label>
        <input type="number" id="simTime" value="60" step="1" min="1">

        <button id="startSimulationBtn">開始模擬</button>
        <button id="toggleAnimationBtn">暫停播放</button>

        <div id="simulation-status">
            模擬進度: <span id="currentStep">0</span> / <span id="totalSteps">0</span><br>
            總累計水量: <span id="totalAccumulatedWater">0.00</span> m³ (<span id="totalAccumulatedWaterMM">0.00</span> mm)<br>
            最大積水深度: <span id="maxWaterDepth">0.00</span> m
        </div>
    </div>

    <div id="loading-overlay">載入中 / 模擬中... 請稍候</div>

    <!-- Three.js 函式庫，直接從 CDN 引入 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Three.js 場景設定 ---
        let scene, camera, renderer, controls;
        let terrainMesh, waterMesh;
        let originalTerrainData = []; // 擴展後的地形高程數據 (不含水)
        let rows, cols, dx_val, dy_val;
        let simulationInterval; // 用於控制 setInterval 的 ID
        let isPaused = false; // 控制播放/暫停的狀態
        let minTerrainHeight = 0; // 地形最低點
        let maxTerrainHeight = 0; // 地形最高點

        const WATER_COLOR_BASE = new THREE.Color(0x0077ff); // 基本水藍色
        const WATER_COLOR_DEEP = new THREE.Color(0x003366); // 深水顏色
        const MAX_WATER_DEPTH_FOR_COLOR = 0.5; // 水深超過 0.5m 開始變色

        function initThreeJS() {
            // 如果已經有 canvas 元素，先移除
            const existingCanvas = document.querySelector('canvas');
            if (existingCanvas) {
                document.body.removeChild(existingCanvas);
            }

            // 清理舊的 Three.js 實例和記憶體
            if (scene) {
                scene.traverse(object => {
                    if (object.isMesh) {
                        object.geometry.dispose();
                        if (object.material.isMaterial) {
                            cleanMaterial(object.material);
                        } else {
                            for (const material of object.material) cleanMaterial(material);
                        }
                    }
                });
                scene.clear();
            }
            if (renderer) renderer.dispose();
            if (controls) controls.dispose();
            if (simulationInterval) clearInterval(simulationInterval); // 停止任何進行中的動畫

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xadd8e6); // 天空藍

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 環境光
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // 方向光 (模擬太陽)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // 稍微亮一點
            directionalLight.position.set(rows * dx_val * 0.5, Math.max(rows * dx_val, cols * dy_val) * 2, cols * dy_val * 0.5);
            directionalLight.castShadow = true; // 啟用陰影 (需要 renderer.shadowMap.enabled = true)
            scene.add(directionalLight);

            // 設置渲染器以啟用陰影
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 柔和陰影

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            // 初始相機位置和目標，使其居中並能看到整個地形
            const centerX = cols * dx_val / 2;
            const centerY = rows * dy_val / 2;
            const terrainCenterZ = (minTerrainHeight + maxTerrainHeight) / 2; // 地形中心高度

            // 根據地形尺寸和高程範圍調整相機初始位置
            const maxDim = Math.max(rows * dx_val, cols * dy_val);
            camera.position.set(centerX + maxDim * 0.8, maxDim * 1.2 + (maxTerrainHeight - minTerrainHeight) * 2, centerY + maxDim * 0.8);
            controls.target.set(centerX, terrainCenterZ, centerY); // 目標設在地形中心高度
            controls.update();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function cleanMaterial(material) {
            material.dispose();
            // dispose textures
            for (const key of Object.keys(material)) {
                const value = material[key];
                if (value && typeof value === 'object' && 'minFilter' in value) {
                    value.dispose();
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 建立地形模型 ---
        function createTerrainAndWater(heightMapArray, r, c, dx, dy) {
            originalTerrainData = heightMapArray; // 這是擴展後的地形數據
            rows = r;
            cols = c;
            dx_val = dx;
            dy_val = dy;

            // 計算地形的最低和最高點
            minTerrainHeight = Infinity;
            maxTerrainHeight = -Infinity;
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    minTerrainHeight = Math.min(minTerrainHeight, originalTerrainData[i][j]);
                    maxTerrainHeight = Math.max(maxTerrainHeight, originalTerrainData[i][j]);
                }
            }

            // 初始化 Three.js 場景 (確保在創建 mesh 之前調用)
            initThreeJS(); 

            // 地形網格
            const terrainGeometry = new THREE.PlaneGeometry(cols * dx_val, rows * dy_val, cols - 1, rows - 1);
            const terrainVertices = terrainGeometry.attributes.position.array;

            // 調整頂點高度
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const terrainVertexIndex = (i * cols + j) * 3 + 2; // Z軸
                    terrainVertices[terrainVertexIndex] = originalTerrainData[i][j]; // 將地形高程賦給Z軸
                }
            }
            terrainGeometry.computeVertexNormals(); 

            // 使用 MeshPhongMaterial 讓地形有更好的光照效果
            const terrainMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513, // 棕色
                specular: 0x111111, // 較低的鏡面反射
                shininess: 30, // 光澤度
                flatShading: true // 平面著色，看起來更有稜角
            }); 
            terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);

            // 使地形中心位於 (0,0,0) 附近，便於旋轉
            terrainMesh.position.x = -cols * dx_val / 2;
            terrainMesh.position.y = -rows * dy_val / 2; // Three.js 預設 Y 軸向上，這裡將平面放在 X-Y
            terrainMesh.rotation.x = -Math.PI / 2; // 將平面從 X-Y 旋轉到 X-Z (Z 軸向上)

            terrainMesh.receiveShadow = true; // 地形接收陰影
            terrainMesh.castShadow = true; // 地形投射陰影 (如果需要)
            scene.add(terrainMesh);


            // 水面網格 (與地形網格結構相同，但 Z 值將動態更新)
            const waterGeometry = new THREE.PlaneGeometry(cols * dx_val, rows * dy_val, cols - 1, rows - 1);
            const waterVertices = waterGeometry.attributes.position.array;

            // 水面初始高度與地形一致或略高，會根據水深更新
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const waterVertexIndex = (i * cols + j) * 3 + 2; // Z軸
                    waterVertices[waterVertexIndex] = originalTerrainData[i][j] + 0.01; // 略高於地形避免Z-fighting
                }
            }
            waterGeometry.computeVertexNormals();

            // 水面材質
            waterMesh = new THREE.Mesh(waterGeometry, new THREE.MeshPhongMaterial({ 
                color: WATER_COLOR_BASE, 
                transparent: true, 
                opacity: 0.0, // 初始完全透明
                side: THREE.DoubleSide,
                specular: 0xaaaaaa, // 增加鏡面反射，讓水看起來有光澤
                shininess: 100 // 更高的光澤度
            }));
            waterMesh.position.x = terrainMesh.position.x;
            waterMesh.position.y = terrainMesh.position.y;
            waterMesh.rotation.x = terrainMesh.rotation.x; // 與地形保持一致的旋轉

            waterMesh.receiveShadow = true; // 水面接收陰影
            waterMesh.castShadow = true; // 水面投射陰影
            scene.add(waterMesh);
        }

        // --- 更新水面顯示 ---
        function updateWaterDisplay(waterDepthArray, current_step_num, total_steps_num) {
            if (!waterMesh || !originalTerrainData.length || isPaused) return;

            const waterVertices = waterMesh.geometry.attributes.position.array;
            let maxCurrentWaterDepth = 0;
            let totalAccumulatedWaterVolume = 0; // 總累積水量 (m³)

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const vertexIndex = (i * cols + j) * 3 + 2; // Z軸

                    const terrainHeight = originalTerrainData[i][j];
                    const waterDepth = waterDepthArray[i][j];

                    maxCurrentWaterDepth = Math.max(maxCurrentWaterDepth, waterDepth);
                    totalAccumulatedWaterVolume += waterDepth * dx_val * dy_val; // 每個網格的體積累積 (m³)

                    // 水面高度 = 地形高度 + 水深
                    // 確保水面高度不會低於地形高度，並加一個小偏移避免 Z-fighting
                    waterVertices[vertexIndex] = terrainHeight + waterDepth + 0.01; 
                    
                    // 調整水的顏色和透明度
                    const material = waterMesh.material;
                    if (waterDepth > 0) {
                        const ratio = Math.min(1, waterDepth / MAX_WATER_DEPTH_FOR_COLOR); // 將水深歸一化到 0-1
                        // 顏色從基本藍色漸變到深藍色
                        const interpolatedColor = new THREE.Color().copy(WATER_COLOR_BASE).lerp(WATER_COLOR_DEEP, ratio);
                        material.color.copy(interpolatedColor);
                        material.opacity = Math.min(0.5 + ratio * 0.4, 0.9); // 透明度隨水深增加，最大 0.9
                    } else {
                        material.opacity = 0; // 沒有水就完全透明
                    }
                }
            }
            waterMesh.geometry.attributes.position.needsUpdate = true; // 告知 Three.js 幾何體已更新
            waterMesh.geometry.computeVertexNormals(); // 重新計算水面法線以正確渲染光照

            // 更新狀態顯示
            document.getElementById('maxWaterDepth').textContent = maxCurrentWaterDepth.toFixed(3) + ' m';
            document.getElementById('totalAccumulatedWater').textContent = totalAccumulatedWaterVolume.toFixed(3) + ' m³';
            document.getElementById('totalAccumulatedWaterMM').textContent = (totalAccumulatedWaterVolume * 1000).toFixed(2); // 轉換為毫米
            document.getElementById('currentStep').textContent = current_step_num; // 顯示當前讀取的步數 (從後端來的已經是當前步)
            document.getElementById('totalSteps').textContent = total_steps_num;
        }

        // --- 播放/暫停功能 ---
        document.getElementById('toggleAnimationBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            const button = document.getElementById('toggleAnimationBtn');
            if (isPaused) {
                clearInterval(simulationInterval); // 停止動畫更新
                button.textContent = "繼續播放";
            } else {
                // 從當前步驟繼續播放
                updateWaterDepthPeriodically(parseInt(document.getElementById('totalSteps').textContent), parseInt(document.getElementById('currentStep').textContent));
                button.textContent = "暫停播放";
            }
        });

        // --- 前端事件處理和 API 互動 ---
        document.getElementById('terrainFile').addEventListener('change', (event) => {
            const fileName = event.target.files[0] ? event.target.files[0].name : "尚未選擇檔案";
            document.getElementById('file-path-display').textContent = `檔案路徑：${fileName}`;
        });

        document.getElementById('startSimulationBtn').addEventListener('click', async () => {
            const terrainFile = document.getElementById('terrainFile').files[0];
            const dx = document.getElementById('dx').value;
            const dy = document.getElementById('dy').value;
            const rainfallType = document.getElementById('rainfallType').value;
            const simTime = document.getElementById('simTime').value;

            if (!terrainFile) {
                alert('請上傳地形 Excel 檔案！');
                return;
            }
            if (isNaN(parseFloat(dx)) || isNaN(parseFloat(dy)) || isNaN(parseInt(simTime))) {
                alert('請輸入有效的數字參數！');
                return;
            }

            document.getElementById('loading-overlay').style.display = 'flex'; // 顯示載入中
            document.getElementById('startSimulationBtn').disabled = true; // 禁用按鈕
            document.getElementById('toggleAnimationBtn').disabled = true; // 禁用播放/暫停按鈕
            isPaused = false; // 重置暫停狀態
            document.getElementById('toggleAnimationBtn').textContent = "暫停播放";

            if (simulationInterval) clearInterval(simulationInterval); // 清除舊的定時器

            const formData = new FormData();
            formData.append('file', terrainFile);
            formData.append('dx', dx);
            formData.append('dy', dy);
            formData.append('rainfall_type', rainfallType);
            formData.append('sim_time', simTime);

            try {
                // 發送地形和參數到後端
                const response = await fetch('/upload-and-simulate', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();

                if (data.status === "success") {
                    console.log("模擬開始:", data);
                    
                    // createTerrainAndWater 會在內部調用 initThreeJS
                    createTerrainAndWater(data.terrain_data, data.rows, data.cols, data.dx, data.dy);
                    
                    document.getElementById('totalSteps').textContent = data.total_steps;
                    document.getElementById('currentStep').textContent = 0; // 重置顯示為0
                    document.getElementById('totalAccumulatedWater').textContent = '0.00 m³';
                    document.getElementById('totalAccumulatedWaterMM').textContent = '0.00';
                    document.getElementById('maxWaterDepth').textContent = '0.00 m';

                    // 開始定期獲取水深數據
                    // 從第0步開始獲取 (因為後端在upload-and-simulate後會重置為0)
                    updateWaterDepthPeriodically(data.total_steps, 0); 
                    document.getElementById('toggleAnimationBtn').disabled = false; // 啟用播放/暫停按鈕

                } else {
                    alert('錯誤: ' + (data.error || '未知錯誤'));
                }
            } catch (error) {
                console.error('API 請求失敗:', error);
                alert('連線錯誤，請檢查伺服器狀態或後端日誌。');
            } finally {
                document.getElementById('loading-overlay').style.display = 'none'; // 隱藏載入中
                document.getElementById('startSimulationBtn').disabled = false; // 啟用按鈕
            }
        });

        // 定期從後端獲取水深數據並更新顯示
        async function updateWaterDepthPeriodically(total_steps, start_step_index = 0) {
            if (simulationInterval) clearInterval(simulationInterval); // 清除之前的 interval

            let currentFetchingStep = start_step_index; // 記錄當前應該從後端獲取哪個步驟

            simulationInterval = setInterval(async () => {
                if (isPaused) return; // 如果暫停，則不發送請求

                if (currentFetchingStep >= total_steps) {
                    console.log("模擬結束。");
                    clearInterval(simulationInterval);
                    document.getElementById('toggleAnimationBtn').disabled = true; // 模擬結束，禁用暫停/播放按鈕
                    document.getElementById('toggleAnimationBtn').textContent = "模擬結束";
                    return;
                }

                try {
                    // 後端 /get-water-data 已經會自動推進 global_sim_current_step
                    // 所以這裡只需要發送請求即可
                    const response = await fetch('/get-water-data'); 
                    const data = await response.json();

                    if (data.status === "simulation_finished") {
                        console.log("模擬結束 (來自後端)。");
                        clearInterval(simulationInterval);
                        document.getElementById('toggleAnimationBtn').disabled = true;
                        document.getElementById('toggleAnimationBtn').textContent = "模擬結束";
                    } else if (data.error) {
                        console.error("獲取水深數據錯誤:", data.error);
                        clearInterval(simulationInterval);
                        alert("模擬過程中發生錯誤: " + data.error);
                    } else {
                        updateWaterDisplay(data.water_depth, data.current_step, data.total_steps);
                        currentFetchingStep = data.current_step + 1; // 更新前端知道的下一個要獲取的步驟
                    }
                } catch (error) {
                    console.error('獲取水深數據失敗:', error);
                    clearInterval(simulationInterval);
                    alert('連線錯誤，無法獲取實時數據。');
                }
            }, 500); // 每 500 毫秒 (0.5 秒) 更新一次
        }
    </script>
</body>
</html>
